<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Firestoreãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body {
        font-family: "Segoe UI", "Meiryo", sans-serif;
        background: #f8f9fa;
        margin: 0;
        padding: 0;
      }
      .container {
        max-width: 800px;
        margin: 40px auto;
        background: #fff;
        border-radius: 12px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        padding: 32px;
      }
      h1 {
        font-size: 2rem;
        margin-bottom: 24px;
      }
      .result {
        margin-top: 24px;
      }
      .success {
        color: #28a745;
      }
      .error {
        color: #dc3545;
      }
      button {
        background: #007bff;
        color: #fff;
        border: none;
        padding: 10px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 1rem;
        margin: 8px 0;
      }
      button:disabled {
        background: #aaa;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Firestoreãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬</h1>
      <button onclick="runMakerPerformanceTest()">
        ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
      </button>
      <div id="firestoreResult" class="result"></div>
    </div>
    <script type="module">
      // Aggregation Queriesãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–¢æ•°

      // Makerå°‚ç”¨ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆmaker.jsã®æ©Ÿèƒ½ã‚’å†å®Ÿè£…ï¼‰
      async function runPerformanceTestForMaker(userId) {
        // Firebase imports (ãƒ­ãƒ¼ã‚«ãƒ«ã§ä½¿ç”¨)
        const { getCountFromServer } = await import(
          "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js"
        );

        console.log("ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒãƒ†ã‚¹ãƒˆé–‹å§‹ ğŸš€");
        console.log(`ãƒ†ã‚¹ãƒˆå¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼: ${userId}`);

        // å¾“æ¥æ–¹æ³•ã®ãƒ†ã‚¹ãƒˆ
        const legacyResult = await testLegacyMethodLocal(userId);
        await new Promise((resolve) => setTimeout(resolve, 1000)); // 1ç§’å¾…æ©Ÿ
        const aggregationResult = await testAggregationMethodLocal(
          userId,
          getCountFromServer
        );

        // æ¯”è¼ƒçµæœã‚’ãƒ­ã‚°å‡ºåŠ›
        console.log("\nğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¯”è¼ƒçµæœ ğŸ“Š");
        console.log("=====================================");

        if (legacyResult.error) {
          console.log("âŒ å¾“æ¥æ–¹æ³•: ã‚¨ãƒ©ãƒ¼ -", legacyResult.error);
        } else {
          console.log(
            `â±ï¸ å¾“æ¥æ–¹æ³•: ${legacyResult.time.toFixed(2)}ms (${
              legacyResult.docCount
            }ä»¶èª­ã¿å–ã‚Š)`
          );
        }

        if (aggregationResult.error) {
          console.log("âŒ Aggregationæ–¹æ³•: ã‚¨ãƒ©ãƒ¼ -", aggregationResult.error);
        } else {
          console.log(
            `âš¡ Aggregationæ–¹æ³•: ${aggregationResult.time.toFixed(2)}ms (${
              aggregationResult.queryCount
            }ã‚¯ã‚¨ãƒª)`
          );
        }

        if (!legacyResult.error && !aggregationResult.error) {
          const improvement =
            ((legacyResult.time - aggregationResult.time) / legacyResult.time) *
            100;
          console.log(
            `ğŸ“ˆ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„: ${
              improvement > 0 ? "+" : ""
            }${improvement.toFixed(1)}%`
          );

          if (improvement > 0) {
            console.log(
              `ğŸ‰ Aggregation QueriesãŒ ${(
                legacyResult.time / aggregationResult.time
              ).toFixed(1)}å€é«˜é€Ÿï¼`
            );
          } else {
            console.log(
              `âš ï¸ å¾“æ¥æ–¹æ³•ãŒ ${(
                aggregationResult.time / legacyResult.time
              ).toFixed(1)}å€é«˜é€Ÿ`
            );
          }
        }

        console.log("=====================================\n");
        return { legacy: legacyResult, aggregation: aggregationResult };
      }

      // å¾“æ¥æ–¹æ³•ãƒ†ã‚¹ãƒˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè£…ï¼‰
      async function testLegacyMethodLocal(userId) {
        console.log("=== å¾“æ¥æ–¹æ³• ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹ ===");
        const startTime = performance.now();

        try {
          const scanItemsSnapshot = await getDocs(collection(db, "scanItems"));
          console.log("å–å¾—ã—ãŸã‚¹ã‚­ãƒ£ãƒ³ã‚¢ã‚¤ãƒ†ãƒ æ•°:", scanItemsSnapshot.size);

          const scanCounts = {};
          scanItemsSnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.item_no) {
              scanCounts[data.item_no] = (scanCounts[data.item_no] || 0) + 1;
            }
          });

          const endTime = performance.now();
          const executionTime = endTime - startTime;

          console.log("=== å¾“æ¥æ–¹æ³• ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµæœ ===");
          console.log(`å®Ÿè¡Œæ™‚é–“: ${executionTime.toFixed(2)}ms`);
          console.log(`èª­ã¿å–ã‚Šãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•°: ${scanItemsSnapshot.size}`);
          console.log("=========================================");

          return {
            method: "legacy",
            time: executionTime,
            docCount: scanItemsSnapshot.size,
            results: scanCounts,
          };
        } catch (error) {
          console.error("å¾“æ¥æ–¹æ³•ãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:", error);
          return { method: "legacy", error: error.message };
        }
      }

      // Aggregationæ–¹æ³•ãƒ†ã‚¹ãƒˆï¼ˆãƒ­ãƒ¼ã‚«ãƒ«å®Ÿè£…ï¼‰
      async function testAggregationMethodLocal(userId, getCountFromServer) {
        console.log("=== Aggregation Queries ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆé–‹å§‹ ===");
        const startTime = performance.now();

        try {
          // ã¾ãšãƒ¡ãƒ¼ã‚«ãƒ¼é–¢é€£ã‚¢ã‚¤ãƒ†ãƒ ã‚’å–å¾—
          const itemsQuery = query(
            collection(db, "items"),
            where("maker_code", "==", userId),
            orderBy("item_no", "asc")
          );

          const itemsSnapshot = await getDocs(itemsQuery);
          const scanCounts = {};
          let totalQueries = 0;

          // å„ã‚¢ã‚¤ãƒ†ãƒ ã”ã¨ã«å€‹åˆ¥ã«ã‚«ã‚¦ãƒ³ãƒˆã‚’å–å¾—ï¼ˆä¸¦åˆ—å‡¦ç†ï¼‰
          const countPromises = [];
          const itemNumbers = [];

          itemsSnapshot.forEach((doc) => {
            const data = doc.data();
            if (data.item_no) {
              itemNumbers.push(data.item_no);
              const countQuery = query(
                collection(db, "scanItems"),
                where("item_no", "==", data.item_no)
              );
              countPromises.push(getCountFromServer(countQuery));
              totalQueries++;
            }
          });

          // å…¨ã¦ã®ã‚«ã‚¦ãƒ³ãƒˆã‚¯ã‚¨ãƒªã‚’ä¸¦åˆ—å®Ÿè¡Œ
          const countResults = await Promise.all(countPromises);

          // çµæœã‚’ãƒãƒƒãƒ”ãƒ³ã‚°
          itemNumbers.forEach((itemNo, index) => {
            scanCounts[itemNo] = countResults[index].data().count;
          });

          const endTime = performance.now();
          const executionTime = endTime - startTime;

          console.log("=== Aggregation Queries ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµæœ ===");
          console.log(`å®Ÿè¡Œæ™‚é–“: ${executionTime.toFixed(2)}ms`);
          console.log(`ã‚¢ã‚¤ãƒ†ãƒ æ•°: ${itemNumbers.length}`);
          console.log(`ã‚¯ã‚¨ãƒªæ•°: ${totalQueries}`);
          console.log(
            `å¹³å‡ã‚¯ã‚¨ãƒªæ™‚é–“: ${(executionTime / totalQueries).toFixed(2)}ms`
          );
          console.log("=============================================");

          return {
            method: "aggregation",
            time: executionTime,
            itemCount: itemNumbers.length,
            queryCount: totalQueries,
            results: scanCounts,
          };
        } catch (error) {
          console.error("Aggregation Queriesãƒ†ã‚¹ãƒˆã‚¨ãƒ©ãƒ¼:", error);
          return { method: "aggregation", error: error.message };
        }
      }
    </script>
  </body>
</html>
